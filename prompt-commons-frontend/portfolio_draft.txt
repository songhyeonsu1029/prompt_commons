[1. 프로젝트 개요]
- 프로젝트명: Prompt Commons (개발자 프롬프트 공유 및 검증 플랫폼)
- 개발 기간: 2024.11 ~ 2024.12 (약 1개월)
- 참여 인원: 4명
- 나의 역할: Full Stack Developer
  - 검색 엔진 구축 (Elasticsearch + Gemini AI)
  - 프롬프트 버전 관리 시스템 설계 및 구현
  - 백엔드 API 및 데이터 동기화 로직 개발

[2. 기술 스택]
- Languages: JavaScript (Node.js v20+), SQL
- Frameworks: React 19, Express 5.1
- Database: MySQL (Prisma ORM), Elasticsearch 8.x
- AI/ML: Google Gemini Pro (Embeddings & Text Generation)
- Tools: Docker, React Query, TailwindCSS, Jest

[3. 주요 기능]
- AI 기반 하이브리드 검색: 단순 키워드 매칭을 넘어, 사용자의 '검색 의도'와 '문제 상황'을 이해하는 시맨틱 검색 제공.
- 프롬프트 버전 제어 (PVC): Git과 유사한 방식으로 프롬프트의 수정 이력을 관리하고, 버전별 차이를 추적.
- 이원화된 댓글 시스템: 일반적인 '토론'과 구조화된 '검증 리포트(Reproduction Report)'를 분리하여 신뢰도 데이터 축적.
- 재현 검증 시스템: 실험 결과의 재현 가능성을 검증하고, 성공/실패 여부와 상세 리포트를 체계적으로 수집하여 데이터 신뢰성 확보.

[4. 문제 해결 사례]

사례 1: 사용자의 모호한 검색 의도 파악 및 검색 정확도 향상

[직면한 문제]
저장된 실험 데이터는 구조화된 텍스트(Code, JSON 등)인 반면, 사용자의 검색어는 비정형 평문(Natural Language)이라는 '데이터 형태의 불일치'가 존재함. 이로 인해 의미적으로는 유사하더라도 벡터 공간에서의 거리가 멀어져 검색 정확도가 떨어지는 문제가 발생함.

[해결 과정: 관점 기반 검색 쿼리 생성 (Perspective-based Query Generation)]
단순히 실험 본문을 벡터화하는 대신, "사용자가 이 실험을 찾을 때 어떤 문장으로 검색할까?"를 역으로 추론하여 해결함.
Gemini AI를 활용해 실험 내용을 바탕으로 사용자가 검색할 법한 문장을 3가지 관점(Perspective)에서 생성하고, 이 '생성된 검색 쿼리'를 벡터화하여 저장함.

1. 관점 분해 (Perspective Generation):
   실험 데이터를 분석하여 다음 3가지 관점의 '가상 검색 쿼리'를 생성:
   - Problem 관점: "React hydration error 해결하는 방법" (문제 상황 중심)
   - Tech 관점: "Next.js 14 서버 컴포넌트 설정" (기술 스택 중심)
   - Solution 관점: "useEffect 의존성 배열 최적화 예시" (해결책 중심)

2. 쿼리 확장 (Query Expansion):
   사용자의 검색어를 입력받으면, AI가 이를 분석하여 '핵심 키워드'와 '확장된 쿼리'를 생성.

3. 하이브리드 매칭:
   Elasticsearch의 kNN 검색을 통해 3가지 벡터 필드(vec_problem, vec_tech, vec_solution)에 대해 각각 유사도를 계산하고, 가중치를 다르게 부여하여 종합 점수 산출.

[구현 코드 (핵심 로직)]

// 1. 프롬프트를 3가지 관점으로 분해하여 임베딩 생성
async function indexExperiment(params) {
  // ...
  // AI를 통해 Problem, Tech, Solution 관점 생성
  const perspectives = await generateSearchPerspectives({ title, promptText, aiModel });

  // 각 관점별로 별도의 벡터 생성 (Multi-Vector)
  const vec_problem = await getEmbedding(perspectives.problem);
  const vec_tech = await getEmbedding(perspectives.tech);
  const vec_solution = await getEmbedding(perspectives.solution);

  const doc = {
    // ...
    vec_problem, // 문제 상황 벡터
    vec_tech,    // 기술 스택 벡터
    vec_solution // 해결책 벡터
  };
  // Elasticsearch 인덱싱 수행
  // ...
}

// 2. 검색 시 쿼리 의도 분석 및 하이브리드 검색
async function semanticSearch({ query }) {
  // ...
  // 사용자 쿼리 의도 분석 (Gemini)
  const queryAnalysis = await analyzeQuery(trimmedQuery);
  const embedding = await getEmbedding(queryAnalysis.expandedQuery);

  const searchBody = {
    knn: [
      { field: 'vec_problem', query_vector: embedding, boost: 0.3 }, // 문제 상황 매칭
      { field: 'vec_tech', query_vector: embedding, boost: 0.3 },    // 기술 스택 매칭
      { field: 'vec_solution', query_vector: embedding, boost: 0.4 } // 해결책 매칭 (가중치 높음)
    ],
    query: {
      bool: {
        should: [
          // 추출된 핵심 키워드로 정확도 보정
          { multi_match: { query: queryAnalysis.keywords.join(' '), fields: ['title^7', 'tags^5'], boost: 0.6 } }
        ]
      }
    }
  };
  // ...
}

[결과 및 학습점]
- 성능 개선: 단순 키워드 검색 대비 자연어 질의에 대한 상위 5개 결과 적합도(Top-5 Relevance)가 약 40%에서 85%로 대폭 향상됨.
- 학습점: RAG(Retrieval-Augmented Generation) 아키텍처에서 '인덱싱 단계의 데이터 구조화'가 검색 품질에 미치는 결정적인 영향을 체감함.

[5. 시스템 아키텍쳐 및 배포]
- Architecture:
  [Client (React)] -> [API Gateway (Express)] -> [Search Service] -> [Elasticsearch]
                                             -> [Core Service] -> [MySQL]
                                             -> [AI Service (Gemini)]
- Data Sync: MySQL의 원본 데이터가 변경될 때마다 Elasticsearch에 실시간/배치로 동기화하는 파이프라인 구축.
- Deployment: Docker Container 기반의 마이크로서비스 배포.
